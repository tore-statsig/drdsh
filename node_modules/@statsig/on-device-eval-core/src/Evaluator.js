"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Evaluator = void 0;
const sha256_1 = require("@statsig/sha256");
const EvaluationComparison_1 = require("./EvaluationComparison");
const EvaluationResult_1 = require("./EvaluationResult");
const CONDITION_SEGMENT_COUNT = 10 * 1000;
const USER_BUCKET_COUNT = 1000;
class Evaluator {
    constructor(_store) {
        this._store = _store;
    }
    evaluateGate(name, user) {
        const { spec, details } = this._getSpecAndDetails('gate', name);
        if (!spec) {
            return { evaluation: null, details };
        }
        const result = this._evaluateSpec(spec, user);
        const evaluation = (0, EvaluationResult_1.resultToGateEval)(spec, result);
        this._handleUnsupportedEvaluation(result, details);
        return { evaluation, details };
    }
    evaluateConfig(name, user) {
        const { spec, details } = this._getSpecAndDetails('config', name);
        if (!spec) {
            return { evaluation: null, details };
        }
        const result = this._evaluateSpec(spec, user);
        const evaluation = (0, EvaluationResult_1.resultToConfigEval)(spec, result);
        this._handleUnsupportedEvaluation(result, details);
        return { evaluation, details };
    }
    evaluateLayer(name, user) {
        var _a;
        const { spec, details } = this._getSpecAndDetails('layer', name);
        if (!spec) {
            return { evaluation: null, details };
        }
        const result = this._evaluateSpec(spec, user);
        const experimentName = (_a = result === null || result === void 0 ? void 0 : result.allocated_experiment_name) !== null && _a !== void 0 ? _a : '';
        const experimentSpec = this._store.getSpecAndSourceInfo('config', experimentName).spec;
        const evaluation = (0, EvaluationResult_1.resultToLayerEval)(spec, experimentSpec, result);
        this._handleUnsupportedEvaluation(result, details);
        return { evaluation, details };
    }
    _handleUnsupportedEvaluation(evaluation, details) {
        if (evaluation.unsupported) {
            details.reason = 'Unsupported';
        }
    }
    getParamStoreConfig(name) {
        var _a;
        const paramStoreAndSourceInfo = this._store.getParamStoreAndSourceInfo(name);
        const details = this._getEvaluationDetails(paramStoreAndSourceInfo);
        return {
            config: (_a = paramStoreAndSourceInfo.paramStoreConfig) !== null && _a !== void 0 ? _a : null,
            details,
        };
    }
    _getSpecAndDetails(kind, name) {
        const specAndSourceInfo = this._store.getSpecAndSourceInfo(kind, name);
        const details = this._getEvaluationDetails(specAndSourceInfo);
        return { details, spec: specAndSourceInfo.spec };
    }
    _getEvaluationDetails(info) {
        const { source, lcut, receivedAt } = info;
        if (source === 'Uninitialized' || source === 'NoValues') {
            return { reason: source };
        }
        const subreason = ('spec' in info ? info.spec : info.paramStoreConfig) == null
            ? 'Unrecognized'
            : 'Recognized';
        const reason = `${source}:${subreason}`;
        return { reason, lcut, receivedAt };
    }
    _evaluateSpec(spec, user) {
        const defaultValue = _isRecord(spec.defaultValue)
            ? spec.defaultValue
            : undefined;
        if (!spec.enabled) {
            return (0, EvaluationResult_1.makeEvalResult)({
                json_value: defaultValue,
                rule_id: 'disabled',
            });
        }
        const exposures = [];
        for (const rule of spec.rules) {
            const result = this._evaluateRule(rule, user);
            if (result.unsupported) {
                return result;
            }
            exposures.push(...result.secondary_exposures);
            if (!result.bool_value) {
                continue;
            }
            const delegateResult = this._evaluateDelegate(rule.configDelegate, user, exposures);
            if (delegateResult) {
                return delegateResult;
            }
            const pass = _evalPassPercent(rule, user, spec);
            return (0, EvaluationResult_1.makeEvalResult)({
                rule_id: result.rule_id,
                bool_value: pass,
                json_value: pass ? result.json_value : defaultValue,
                secondary_exposures: exposures,
                undelegated_secondary_exposures: exposures,
                is_experiment_group: result.is_experiment_group,
                group_name: result.group_name,
            });
        }
        return (0, EvaluationResult_1.makeEvalResult)({
            json_value: defaultValue,
            secondary_exposures: exposures,
            undelegated_secondary_exposures: exposures,
            rule_id: 'default',
        });
    }
    _evaluateRule(rule, user) {
        const exposures = [];
        let pass = true;
        for (const condition of rule.conditions) {
            const result = this._evaluateCondition(condition, user);
            if (result.unsupported) {
                return result;
            }
            exposures.push(...result.secondary_exposures);
            if (!result.bool_value) {
                pass = false;
            }
        }
        return (0, EvaluationResult_1.makeEvalResult)({
            rule_id: rule.id,
            bool_value: pass,
            json_value: _isRecord(rule.returnValue) ? rule.returnValue : undefined,
            secondary_exposures: exposures,
            is_experiment_group: rule.isExperimentGroup === true,
            group_name: rule.groupName,
        });
    }
    _evaluateCondition(condition, user) {
        var _a, _b, _c;
        let value = null;
        let pass = false;
        const field = condition.field;
        const target = condition.targetValue;
        const idType = condition.idType;
        const type = condition.type;
        switch (type) {
            case 'public':
                return (0, EvaluationResult_1.makeEvalResult)({ bool_value: true });
            case 'pass_gate':
            case 'fail_gate': {
                const name = String(target);
                const result = this._evaluateNestedGate(name, user);
                return (0, EvaluationResult_1.makeEvalResult)({
                    bool_value: type === 'fail_gate' ? !result.bool_value : result.bool_value,
                    secondary_exposures: result.secondary_exposures,
                });
            }
            case 'multi_pass_gate':
            case 'multi_fail_gate':
                return this._evaluateMultiNestedGates(target, type, user);
            case 'user_field':
            case 'ip_based':
            case 'ua_based':
                value = _getFromUser(user, field);
                break;
            case 'environment_field':
                value = _getFromEnvironment(user, field);
                break;
            case 'current_time':
                value = Date.now();
                break;
            case 'user_bucket': {
                const salt = String((_b = (_a = condition.additionalValues) === null || _a === void 0 ? void 0 : _a['salt']) !== null && _b !== void 0 ? _b : '');
                const unitID = (_c = _getUnitIDFromUser(user, idType)) !== null && _c !== void 0 ? _c : '';
                const userHash = _computeUserHash(salt + '.' + unitID);
                value = Number(userHash % BigInt(USER_BUCKET_COUNT));
                break;
            }
            case 'unit_id':
                value = _getUnitIDFromUser(user, idType);
                break;
            default:
                return (0, EvaluationResult_1.makeEvalResult)({ unsupported: true });
        }
        const operator = condition.operator;
        switch (operator) {
            case 'gt':
            case 'gte':
            case 'lt':
            case 'lte':
                pass = EvaluationComparison_1.default.compareNumbers(value, target, operator);
                break;
            case 'version_gt':
            case 'version_gte':
            case 'version_lt':
            case 'version_lte':
            case 'version_eq':
            case 'version_neq':
                pass = EvaluationComparison_1.default.compareVersions(value, target, operator);
                break;
            case 'any':
            case 'none':
            case 'str_starts_with_any':
            case 'str_ends_with_any':
            case 'str_contains_any':
            case 'str_contains_none':
            case 'any_case_sensitive':
            case 'none_case_sensitive':
                pass = EvaluationComparison_1.default.compareStringInArray(value, target, operator);
                break;
            case 'str_matches':
                pass = EvaluationComparison_1.default.compareStringWithRegEx(value, target);
                break;
            case 'before':
            case 'after':
            case 'on':
                pass = EvaluationComparison_1.default.compareTime(value, target, operator);
                break;
            case 'eq':
                // eslint-disable-next-line eqeqeq
                pass = value == target;
                break;
            case 'neq':
                // eslint-disable-next-line eqeqeq
                pass = value != target;
                break;
            case 'in_segment_list':
            case 'not_in_segment_list':
                return (0, EvaluationResult_1.makeEvalResult)({ unsupported: true });
            case 'array_contains_any':
            case 'array_contains_none': {
                if (!Array.isArray(target)) {
                    pass = false;
                    break;
                }
                if (!Array.isArray(value)) {
                    pass = false;
                    break;
                }
                const res = EvaluationComparison_1.default.arrayHasValue(value, target);
                pass = operator === 'array_contains_any' ? res : !res;
                break;
            }
            case 'array_contains_all':
            case 'not_array_contains_all': {
                if (!Array.isArray(target)) {
                    pass = false;
                    break;
                }
                if (!Array.isArray(value)) {
                    pass = false;
                    break;
                }
                const res = EvaluationComparison_1.default.arrayHasAllValues(value, target);
                pass = operator === 'array_contains_all' ? res : !res;
                break;
            }
        }
        return (0, EvaluationResult_1.makeEvalResult)({ bool_value: pass });
    }
    _evaluateDelegate(configDelegate, user, exposures) {
        if (!configDelegate) {
            return null;
        }
        const { spec } = this._store.getSpecAndSourceInfo('config', configDelegate);
        if (!spec) {
            return null;
        }
        const result = this._evaluateSpec(spec, user);
        return (0, EvaluationResult_1.makeEvalResult)(Object.assign(Object.assign({}, result), { allocated_experiment_name: configDelegate, explicit_parameters: spec.explicitParameters, secondary_exposures: exposures.concat(result.secondary_exposures), undelegated_secondary_exposures: exposures }));
    }
    _evaluateNestedGate(name, user) {
        const exposures = [];
        let pass = false;
        const { spec } = this._store.getSpecAndSourceInfo('gate', name);
        if (spec) {
            const result = this._evaluateSpec(spec, user);
            if (result.unsupported) {
                return result;
            }
            pass = result.bool_value;
            exposures.push(...result.secondary_exposures);
            exposures.push({
                gate: name,
                gateValue: String(pass),
                ruleID: result.rule_id,
            });
        }
        return (0, EvaluationResult_1.makeEvalResult)({
            bool_value: pass,
            secondary_exposures: exposures,
        });
    }
    _evaluateMultiNestedGates(gates, type, user) {
        if (!Array.isArray(gates)) {
            return (0, EvaluationResult_1.makeEvalResult)({ unsupported: true });
        }
        const isMultiPassType = type === 'multi_pass_gate';
        const exposures = [];
        let pass = false;
        for (const name of gates) {
            if (typeof name !== 'string') {
                return (0, EvaluationResult_1.makeEvalResult)({ unsupported: true });
            }
            const result = this._evaluateNestedGate(name, user);
            if (result.unsupported) {
                return result;
            }
            exposures.push(...result.secondary_exposures);
            if (isMultiPassType
                ? result.bool_value === true
                : result.bool_value === false) {
                pass = true;
                break;
            }
        }
        return (0, EvaluationResult_1.makeEvalResult)({
            bool_value: pass,
            secondary_exposures: exposures,
        });
    }
}
exports.Evaluator = Evaluator;
function _getUnitIDFromUser(user, idType) {
    var _a, _b, _c;
    if (typeof idType === 'string' && idType.toLowerCase() !== 'userid') {
        return (_b = (_a = user.customIDs) === null || _a === void 0 ? void 0 : _a[idType]) !== null && _b !== void 0 ? _b : (_c = user === null || user === void 0 ? void 0 : user.customIDs) === null || _c === void 0 ? void 0 : _c[idType.toLowerCase()];
    }
    return user.userID;
}
function _evalPassPercent(rule, user, config) {
    var _a, _b;
    if (rule.passPercentage === 100) {
        return true;
    }
    if (rule.passPercentage === 0) {
        return false;
    }
    const hash = _computeUserHash(config.salt +
        '.' +
        ((_a = rule.salt) !== null && _a !== void 0 ? _a : rule.id) +
        '.' +
        ((_b = _getUnitIDFromUser(user, rule.idType)) !== null && _b !== void 0 ? _b : ''));
    return (Number(hash % BigInt(CONDITION_SEGMENT_COUNT)) < rule.passPercentage * 100);
}
function _computeUserHash(userHash) {
    const sha256 = (0, sha256_1.SHA256)(userHash);
    return sha256.dataView().getBigUint64(0, false);
}
function _getFromEnvironment(user, field) {
    if (field == null) {
        return null;
    }
    return _getParameterCaseInsensitive(user.statsigEnvironment, field);
}
function _getParameterCaseInsensitive(object, key) {
    if (object == null) {
        return undefined;
    }
    const asLowercase = key.toLowerCase();
    const keyMatch = Object.keys(object).find((k) => k.toLowerCase() === asLowercase);
    if (keyMatch === undefined) {
        return undefined;
    }
    return object[keyMatch];
}
function _getFromUser(user, field) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    if (field == null || typeof user !== 'object' || user == null) {
        return null;
    }
    const indexableUser = user;
    return ((_h = (_f = (_d = (_b = (_a = indexableUser[field]) !== null && _a !== void 0 ? _a : indexableUser[field.toLowerCase()]) !== null && _b !== void 0 ? _b : (_c = user === null || user === void 0 ? void 0 : user.custom) === null || _c === void 0 ? void 0 : _c[field]) !== null && _d !== void 0 ? _d : (_e = user === null || user === void 0 ? void 0 : user.custom) === null || _e === void 0 ? void 0 : _e[field.toLowerCase()]) !== null && _f !== void 0 ? _f : (_g = user === null || user === void 0 ? void 0 : user.privateAttributes) === null || _g === void 0 ? void 0 : _g[field]) !== null && _h !== void 0 ? _h : (_j = user === null || user === void 0 ? void 0 : user.privateAttributes) === null || _j === void 0 ? void 0 : _j[field.toLowerCase()]);
}
function _isRecord(obj) {
    return obj != null && typeof obj === 'object';
}
