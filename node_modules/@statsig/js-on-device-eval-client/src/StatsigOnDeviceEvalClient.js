"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const client_core_1 = require("@statsig/client-core");
const on_device_eval_core_1 = require("@statsig/on-device-eval-core");
const Network_1 = require("./Network");
const StatsigSpecsDataAdapter_1 = require("./StatsigSpecsDataAdapter");
class StatsigOnDeviceEvalClient extends client_core_1.StatsigClientBase {
    static instance(sdkKey) {
        const instance = (0, client_core_1._getStatsigGlobal)().instance(sdkKey);
        if (instance instanceof StatsigOnDeviceEvalClient) {
            return instance;
        }
        client_core_1.Log.warn((0, client_core_1._isServerEnv)()
            ? 'StatsigOnDeviceEvalClient.instance is not supported in server environments'
            : 'Unable to find StatsigOnDeviceEvalClient instance');
        return new StatsigOnDeviceEvalClient(sdkKey !== null && sdkKey !== void 0 ? sdkKey : '');
    }
    constructor(sdkKey, options = null) {
        var _a;
        client_core_1.SDKType._setClientType(sdkKey, 'js-on-device-eval-client');
        const network = new Network_1.default(options);
        super(sdkKey, (_a = options === null || options === void 0 ? void 0 : options.dataAdapter) !== null && _a !== void 0 ? _a : new StatsigSpecsDataAdapter_1.StatsigSpecsDataAdapter(), network, options);
        this._network = network;
        this._store = new on_device_eval_core_1.SpecStore();
        this._evaluator = new on_device_eval_core_1.Evaluator(this._store);
        this._sdkInstanceID = (0, client_core_1.getUUID)();
    }
    initializeSync(options) {
        if (this.loadingStatus !== 'Uninitialized') {
            return {
                success: true,
                duration: 0,
                source: this._store.getSource(),
                sourceUrl: null,
                error: null,
            };
        }
        this._logger.start();
        return this.updateSync(options);
    }
    initializeAsync(options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._initializePromise) {
                return this._initializePromise;
            }
            this._initializePromise = this._initializeAsyncImpl(options);
            return this._initializePromise;
        });
    }
    updateSync(options) {
        const startTime = performance.now();
        this._store.reset();
        const result = this.dataAdapter.getDataSync();
        this._store.setValuesFromDataAdapter(result);
        this._store.finalize();
        this._setStatus('Ready', result);
        if (!(options === null || options === void 0 ? void 0 : options.disableBackgroundCacheRefresh)) {
            this._runPostUpdate(result);
        }
        return (0, client_core_1.createUpdateDetails)(true, this._store.getSource(), performance.now() - startTime, this._errorBoundary.getLastSeenErrorAndReset(), this._network.getLastUsedInitUrlAndReset());
    }
    updateAsync(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const startTime = performance.now();
            this._store.reset();
            this._setStatus('Loading', null);
            let result = this.dataAdapter.getDataSync();
            this._store.setValuesFromDataAdapter(result);
            result = yield this.dataAdapter.getDataAsync(result, options);
            this._store.setValuesFromDataAdapter(result);
            this._store.finalize();
            this._setStatus('Ready', result);
            return (0, client_core_1.createUpdateDetails)(true, this._store.getSource(), performance.now() - startTime, this._errorBoundary.getLastSeenErrorAndReset(), this._network.getLastUsedInitUrlAndReset());
        });
    }
    getContext() {
        return {
            sdkKey: this._sdkKey,
            options: this._options,
            values: this._store.getValues(),
            errorBoundary: this._errorBoundary,
            session: client_core_1.StatsigSession.get(this._sdkKey),
            stableID: client_core_1.StableID.get(this._sdkKey),
            sdkInstanceID: this._sdkInstanceID,
        };
    }
    checkGate(name, user, options) {
        return this.getFeatureGate(name, user, options).value;
    }
    getFeatureGate(name, user, options) {
        const normalized = this._normalizeUser(user);
        const { evaluation, details } = this._evaluator.evaluateGate(name, normalized);
        const gate = (0, client_core_1._makeFeatureGate)(name, details, evaluation);
        this._enqueueExposure(name, (0, client_core_1._createGateExposure)(normalized, gate), options);
        this.$emt({ name: 'gate_evaluation', gate });
        return gate;
    }
    getDynamicConfig(name, user, options) {
        var _a, _b;
        const normalized = this._normalizeUser(user);
        const { evaluation, details } = this._evaluator.evaluateConfig(name, normalized);
        const config = (0, client_core_1._makeDynamicConfig)(name, details, evaluation);
        const overridden = (_b = (_a = this.overrideAdapter) === null || _a === void 0 ? void 0 : _a.getDynamicConfigOverride) === null || _b === void 0 ? void 0 : _b.call(_a, config, normalized, options);
        const result = overridden !== null && overridden !== void 0 ? overridden : config;
        this._enqueueExposure(name, (0, client_core_1._createConfigExposure)(normalized, result), options);
        this.$emt({ name: 'dynamic_config_evaluation', dynamicConfig: result });
        return result;
    }
    getExperiment(name, user, options) {
        var _a, _b;
        const normalized = this._normalizeUser(user);
        const { evaluation, details } = this._evaluator.evaluateConfig(name, normalized);
        const experiment = (0, client_core_1._makeExperiment)(name, details, evaluation);
        const overridden = (_b = (_a = this.overrideAdapter) === null || _a === void 0 ? void 0 : _a.getExperimentOverride) === null || _b === void 0 ? void 0 : _b.call(_a, experiment, normalized, options);
        const result = overridden !== null && overridden !== void 0 ? overridden : experiment;
        this._enqueueExposure(name, (0, client_core_1._createConfigExposure)(normalized, result), options);
        this.$emt({ name: 'experiment_evaluation', experiment: result });
        return result;
    }
    getLayer(name, user, options) {
        var _a, _b;
        const normalized = this._normalizeUser(user);
        const { evaluation, details } = this._evaluator.evaluateLayer(name, normalized);
        const layer = (0, client_core_1._makeLayer)(name, details, evaluation, (param) => {
            this._enqueueExposure(name, (0, client_core_1._createLayerParameterExposure)(normalized, layer, param), options);
        });
        const overridden = (_b = (_a = this.overrideAdapter) === null || _a === void 0 ? void 0 : _a.getLayerOverride) === null || _b === void 0 ? void 0 : _b.call(_a, layer, normalized, options);
        const result = overridden !== null && overridden !== void 0 ? overridden : layer;
        this.$emt({ name: 'layer_evaluation', layer: result });
        return result;
    }
    logEvent(eventOrName, user, value, metadata) {
        const event = typeof eventOrName === 'string'
            ? {
                eventName: eventOrName,
                value,
                metadata,
            }
            : eventOrName;
        this._logger.enqueue(Object.assign(Object.assign({}, event), { user: this._normalizeUser(user), time: Date.now() }));
    }
    _primeReadyRipcord() {
        this.$on('error', () => {
            this.loadingStatus === 'Loading' && this._finalizeUpdate(null);
        });
    }
    _initializeAsyncImpl(options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!client_core_1.Storage.isReady()) {
                yield client_core_1.Storage.isReadyResolver();
            }
            this._logger.start();
            return this.updateAsync(options);
        });
    }
    _finalizeUpdate(values) {
        this._store.finalize();
        this._setStatus('Ready', values);
    }
    _normalizeUser(user) {
        return (0, client_core_1._normalizeUser)(user, this._options, this._store.getDefaultEnvironment());
    }
    _runPostUpdate(current) {
        this.dataAdapter.getDataAsync(current, { priority: 'low' }).catch((err) => {
            client_core_1.Log.error('An error occurred after update.', err);
        });
    }
}
exports.default = StatsigOnDeviceEvalClient;
